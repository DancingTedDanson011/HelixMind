<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HelixMind Brain</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{overflow:hidden;background:#030308;font-family:'JetBrains Mono',monospace;color:#ccc;user-select:none}
canvas{display:block;width:100vw;height:100vh}

/* ─── HUD ─── */
#hud{position:fixed;inset:0;pointer-events:none;z-index:10;transition:opacity .8s ease}
#hud.hidden{opacity:0}
.hud-panel{position:absolute;pointer-events:auto}

/* Top-left — Identity */
#identity{top:20px;left:24px;font-size:11px;line-height:1.6;opacity:.7}
#identity .title{font-size:14px;font-weight:500;color:#00d4ff;letter-spacing:1px;display:flex;align-items:center;gap:8px}
#identity .title .dot{width:6px;height:6px;border-radius:50%;background:#00ff88;animation:pulse-dot 2s ease infinite}
#identity .stats{color:#556;margin-top:2px}
@keyframes pulse-dot{0%,100%{opacity:.4;transform:scale(.8)}50%{opacity:1;transform:scale(1.2)}}

/* Top-right — Legend */
#legend{top:20px;right:24px;display:flex;flex-direction:column;gap:5px;font-size:10px}
.legend-row{display:flex;align-items:center;gap:8px;cursor:pointer;opacity:.6;transition:opacity .3s}
.legend-row:hover,.legend-row.active{opacity:1}
.legend-dot{width:8px;height:8px;border-radius:50%;flex-shrink:0}
.legend-label{white-space:nowrap}
.legend-count{color:#445;margin-left:auto}

/* Bottom-left — Detail Panel */
#detail{bottom:24px;left:24px;background:rgba(5,5,16,.85);border:1px solid rgba(255,255,255,.06);border-radius:12px;padding:16px 20px;max-width:320px;font-size:11px;line-height:1.7;backdrop-filter:blur(12px);opacity:0;transform:translateY(10px);transition:opacity .4s,transform .4s;pointer-events:none}
#detail.visible{opacity:1;transform:translateY(0);pointer-events:auto}
#detail .detail-label{font-size:14px;font-weight:500;color:#fff;margin-bottom:6px}
#detail .detail-meta{color:#667;display:flex;flex-wrap:wrap;gap:4px 12px}
#detail .detail-meta span{display:flex;align-items:center;gap:4px}
#detail .detail-conn{margin-top:8px;color:#556}
#detail .detail-close{position:absolute;top:8px;right:12px;cursor:pointer;color:#445;font-size:16px}
#detail .detail-close:hover{color:#fff}

/* Bottom-center — Search */
#search-wrap{bottom:24px;left:50%;transform:translateX(-50%);pointer-events:auto}
#search{background:rgba(5,5,16,.7);border:1px solid rgba(255,255,255,.08);border-radius:20px;padding:8px 20px;width:260px;font-family:inherit;font-size:11px;color:#ccc;outline:none;backdrop-filter:blur(10px);transition:border-color .3s,width .3s}
#search:focus{border-color:rgba(0,212,255,.3);width:320px}
#search::placeholder{color:#334}

/* Tooltip */
#tooltip{position:fixed;background:rgba(5,5,16,.9);border:1px solid rgba(255,255,255,.08);border-radius:8px;padding:8px 14px;font-size:10px;line-height:1.6;pointer-events:none;opacity:0;transition:opacity .2s;backdrop-filter:blur(8px);z-index:20;max-width:220px}
#tooltip.visible{opacity:1}
#tooltip .tt-label{color:#fff;font-weight:500;font-size:11px}
#tooltip .tt-meta{color:#556}
</style>
</head>
<body>

<!-- HUD -->
<div id="hud">
  <div id="identity" class="hud-panel">
    <div class="title"><span class="dot"></span> HelixMind Brain</div>
    <div class="stats" id="stats"></div>
  </div>

  <div id="legend" class="hud-panel"></div>

  <div id="detail" class="hud-panel">
    <div class="detail-close" id="detail-close">&times;</div>
    <div class="detail-label" id="detail-label"></div>
    <div class="detail-meta" id="detail-meta"></div>
    <div class="detail-conn" id="detail-conn"></div>
  </div>

  <div id="search-wrap" class="hud-panel">
    <input id="search" type="text" placeholder="Search nodes..." spellcheck="false">
  </div>
</div>

<div id="tooltip">
  <div class="tt-label" id="tt-label"></div>
  <div class="tt-meta" id="tt-meta"></div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// ═══════════════════════════════════════════════════════════════
// CONSTANTS
// ═══════════════════════════════════════════════════════════════

const COLORS = {
  1: '#00ffff', 2: '#00ff88', 3: '#4169e1',
  4: '#8a2be2', 5: '#6c757d', 6: '#ffaa00',
};
const LEVEL_NAMES = {
  1: 'Focus', 2: 'Active', 3: 'Reference',
  4: 'Archive', 5: 'Deep Archive', 6: 'Web Knowledge',
};
// V6: Galaxy Brain — Force-directed 3D graph like a neural galaxy
const LEVEL_STYLE = {
  1: { size: 22, pulse: 2.0, activity: 1.0 },
  2: { size: 20, pulse: 1.5, activity: 0.85 },
  3: { size: 17, pulse: 1.0, activity: 0.7 },
  4: { size: 15, pulse: 0.6, activity: 0.5 },
  5: { size: 13, pulse: 0.3, activity: 0.3 },
  6: { size: 18, pulse: 0.8, activity: 0.7 },
};

function srand(s){const x=Math.sin(s*9301+49297)*49297;return x-Math.floor(x)}

// ═══════════════════════════════════════════════════════════════
// DEMO DATA
// ═══════════════════════════════════════════════════════════════

const T = [
  // L5 Wisdom
  {l:'SOLID Principles',t:'pattern',lv:5},{l:'Separation of Concerns',t:'pattern',lv:5},
  {l:'Test-Driven Development',t:'pattern',lv:5},{l:'Event-Driven Architecture',t:'architecture',lv:5},
  {l:'Functional Composition',t:'pattern',lv:5},{l:'Clean Architecture',t:'architecture',lv:5},
  {l:'Immutable Data',t:'pattern',lv:5},
  // L4 Knowledge
  {l:'React Component Lifecycle',t:'code',lv:4},{l:'TypeScript Generics',t:'code',lv:4},
  {l:'SQL Query Optimization',t:'decision',lv:4},{l:'REST API Design',t:'pattern',lv:4},
  {l:'Git Branching Strategy',t:'decision',lv:4},{l:'Docker Containerization',t:'architecture',lv:4},
  {l:'WebSocket Protocol',t:'code',lv:4},{l:'CSS Grid Layout',t:'code',lv:4},
  {l:'Promise Patterns',t:'pattern',lv:4},{l:'State Machine Design',t:'architecture',lv:4},
  {l:'Middleware Pipeline',t:'pattern',lv:4},{l:'Error Boundaries',t:'pattern',lv:4},
  {l:'Database Indexing',t:'decision',lv:4},{l:'OAuth2 Flow',t:'pattern',lv:4},
  // L3 Context
  {l:'Auth Middleware Refactor',t:'code',lv:3},{l:'Payment Integration',t:'code',lv:3},
  {l:'Dashboard Redesign',t:'summary',lv:3},{l:'API Rate Limiting',t:'code',lv:3},
  {l:'DB Migration v3',t:'code',lv:3},{l:'Search Optimization',t:'code',lv:3},
  {l:'Caching Strategy',t:'decision',lv:3},{l:'WS Reconnection',t:'code',lv:3},
  {l:'Form Validation',t:'code',lv:3},{l:'Image Pipeline',t:'code',lv:3},
  {l:'Email Notifications',t:'code',lv:3},{l:'Role-Based Access',t:'code',lv:3},
  {l:'CI/CD Update',t:'summary',lv:3},{l:'Monitoring Setup',t:'code',lv:3},
  {l:'Performance Profiling',t:'summary',lv:3},{l:'Session Management',t:'code',lv:3},
  {l:'Logging Framework',t:'architecture',lv:3},{l:'Error Handling v2',t:'code',lv:3},
  // L2 Focus
  {l:'Fix Login Redirect',t:'error',lv:2},{l:'Update Dependencies',t:'code',lv:2},
  {l:'Dark Mode Toggle',t:'code',lv:2},{l:'Bundle Size Opt',t:'code',lv:2},
  {l:'Implement Pagination',t:'code',lv:2},{l:'Search Autocomplete',t:'code',lv:2},
  {l:'Fix Memory Leak',t:'error',lv:2},{l:'API Docs Update',t:'summary',lv:2},
  {l:'Export Feature',t:'code',lv:2},{l:'Refactor Settings',t:'code',lv:2},
  {l:'Add Tests for Auth',t:'code',lv:2},{l:'Optimize Queries',t:'code',lv:2},
  // L1 Instant
  {l:'Review PR #247',t:'code',lv:1},{l:'Debug Test Failure',t:'error',lv:1},
  {l:'Deployment Issue',t:'error',lv:1},{l:'Cleanup Imports',t:'code',lv:1},
  {l:'Quick CSS Fix',t:'code',lv:1},{l:'Check CI Status',t:'code',lv:1},
  {l:'Read Error Logs',t:'error',lv:1},{l:'Standup Notes',t:'summary',lv:1},
  {l:'Hotfix: Null Check',t:'error',lv:1},{l:'Merge Conflicts',t:'code',lv:1},
  // L6 Web
  {l:'React 19 Release',t:'pattern',lv:6},{l:'Next.js 15 Migration',t:'pattern',lv:6},
  {l:'Prisma v6 Changelog',t:'pattern',lv:6},{l:'TS 5.7 Features',t:'pattern',lv:6},
  {l:'Tailwind v4 Guide',t:'pattern',lv:6},{l:'Node.js 22 LTS',t:'pattern',lv:6},
  {l:'Bun Benchmarks',t:'pattern',lv:6},{l:'Deno 2.0',t:'pattern',lv:6},
];

const nodes = T.map((n,i)=>({id:'n'+i,label:n.l,type:n.t,level:n.lv,
  relevanceScore:Math.max(.1,1-(n.lv-1)*.15+srand(i*.37)*.2),
  accessCount:Math.floor(srand(i*.53)*50+1)}));

// Generate edges
const E=[];
function addE(s,t,tp,w){if(s<nodes.length&&t<nodes.length)E.push({source:'n'+s,target:'n'+t,type:tp,weight:w})}
// L5 internal
addE(0,1,'similar_to',.8);addE(0,2,'similar_to',.7);addE(3,5,'similar_to',.9);addE(4,6,'similar_to',.6);addE(1,5,'similar_to',.7);
// L5→L4
addE(0,7,'evolves_from',.9);addE(0,10,'evolves_from',.7);addE(2,7,'evolves_from',.8);
addE(3,14,'evolves_from',.8);addE(3,16,'evolves_from',.7);addE(5,12,'evolves_from',.8);
addE(4,15,'evolves_from',.6);addE(1,17,'evolves_from',.7);addE(6,8,'evolves_from',.5);
// L4 internal
addE(7,17,'similar_to',.6);addE(8,15,'similar_to',.5);addE(10,9,'calls',.7);
addE(13,16,'depends_on',.8);addE(11,12,'related_to',.5);addE(14,19,'depends_on',.7);addE(18,9,'calls',.8);
// L4→L3
addE(7,21,'evolves_from',.8);addE(10,23,'evolves_from',.7);addE(9,24,'calls',.6);
addE(13,27,'evolves_from',.7);addE(17,30,'evolves_from',.6);addE(19,31,'evolves_from',.8);
addE(15,28,'calls',.5);addE(16,35,'evolves_from',.7);addE(18,25,'calls',.6);addE(14,36,'calls',.5);
addE(12,22,'related_to',.4);addE(8,37,'calls',.5);
// L3 internal
addE(21,31,'depends_on',.8);addE(22,28,'calls',.6);addE(23,26,'depends_on',.7);
addE(25,27,'depends_on',.5);addE(29,30,'calls',.6);addE(33,34,'similar_to',.5);
addE(24,25,'depends_on',.7);addE(32,33,'related_to',.4);addE(26,36,'calls',.5);addE(35,37,'depends_on',.6);
// L3→L2
addE(21,38,'evolves_from',.7);addE(28,42,'evolves_from',.6);addE(25,43,'evolves_from',.5);
addE(22,40,'calls',.6);addE(23,41,'depends_on',.5);addE(29,44,'evolves_from',.7);
addE(37,46,'evolves_from',.6);addE(26,47,'calls',.5);addE(31,48,'depends_on',.6);addE(24,49,'calls',.4);
// L2 internal
addE(38,46,'related_to',.5);addE(40,41,'similar_to',.4);addE(42,43,'depends_on',.6);
addE(44,45,'calls',.5);addE(47,49,'related_to',.3);
// L2→L1
addE(38,50,'evolves_from',.6);addE(46,51,'calls',.5);addE(40,54,'calls',.4);
addE(42,56,'evolves_from',.5);addE(49,57,'calls',.4);addE(44,52,'depends_on',.5);addE(41,59,'calls',.4);
// L1 internal
addE(50,51,'related_to',.4);addE(52,53,'depends_on',.5);addE(54,55,'similar_to',.3);addE(56,57,'calls',.4);
// L6→various
addE(60,7,'imports',.7);addE(61,21,'imports',.6);addE(62,24,'imports',.5);addE(63,8,'imports',.6);
addE(64,14,'imports',.5);addE(65,13,'imports',.4);addE(66,41,'imports',.5);addE(67,12,'imports',.4);
addE(60,61,'similar_to',.4);addE(63,64,'similar_to',.3);addE(65,66,'similar_to',.3);

const edges = E;
const projectName = 'HelixMind';

// ═══════════════════════════════════════════════════════════════
// POSITIONS
// ═══════════════════════════════════════════════════════════════

const byLevel = {};
nodes.forEach((n,i)=>{if(!byLevel[n.level])byLevel[n.level]=[];byLevel[n.level].push(i)});

// Build nodeIdxMap first (needed for force layout)
const nodeIdxMap={};nodes.forEach((n,i)=>{nodeIdxMap[n.id]=i});

// Force-directed 3D layout
function computeForceLayout(nodeList,edgeList,idxMap){
  const N=nodeList.length;if(N===0)return[];
  // Group nodes by level
  const lvG={};
  for(let i=0;i<N;i++){const lv=nodeList[i].level||3;if(!lvG[lv])lvG[lv]=[];lvG[lv].push(i);}
  // Seed centroids per level
  const lvs=Object.keys(lvG).map(Number).sort();
  const seedC={};const CS=320;
  for(let li=0;li<lvs.length;li++){
    const lv=lvs[li];const golden=2.399963;
    const theta=golden*li*2.5;const phi=Math.acos(1-2*(li+0.5)/Math.max(lvs.length,2));
    seedC[lv]={x:CS*Math.sin(phi)*Math.cos(theta),y:CS*Math.cos(phi),z:CS*Math.sin(phi)*Math.sin(theta)};
  }
  const pos=new Array(N);
  for(let i=0;i<N;i++){
    const lv=nodeList[i].level||3;const c=seedC[lv]||{x:0,y:0,z:0};const SP=100;
    pos[i]={x:c.x+(srand(i*7)-.5)*SP,y:c.y+(srand(i*13)-.5)*SP,z:c.z+(srand(i*19)-.5)*SP};
  }
  const adjL=new Array(N);for(let i=0;i<N;i++)adjL[i]=[];
  for(const e of edgeList){
    const si=idxMap[e.source],ti=idxMap[e.target];
    if(si!==undefined&&ti!==undefined){adjL[si].push(ti);adjL[ti].push(si);}
  }
  const ITER=60,REP=5000,ATT=0.012,CPULL=0.02,IREP=18000,CEN=0.0005,DAMP=0.82;
  const KS=Math.min(N,25);
  const vel=new Array(N);for(let i=0;i<N;i++)vel[i]={x:0,y:0,z:0};
  for(let it=0;it<ITER;it++){
    const temp=1.0-it/ITER;const repS=REP*temp;
    // Dynamic centroids
    const dynC={},dynN={};
    for(let i=0;i<N;i++){
      const lv=nodeList[i].level||3;
      if(!dynC[lv]){dynC[lv]={x:0,y:0,z:0};dynN[lv]=0;}
      dynC[lv].x+=pos[i].x;dynC[lv].y+=pos[i].y;dynC[lv].z+=pos[i].z;dynN[lv]++;
    }
    for(const lv in dynC){dynC[lv].x/=dynN[lv];dynC[lv].y/=dynN[lv];dynC[lv].z/=dynN[lv];}
    for(let i=0;i<N;i++){
      let fx=0,fy=0,fz=0;const myLv=nodeList[i].level||3;
      for(let k=0;k<KS;k++){
        const j=Math.floor(srand(it*10007+i*997+k*31)*N);if(j===i)continue;
        const dx=pos[i].x-pos[j].x,dy=pos[i].y-pos[j].y,dz=pos[i].z-pos[j].z;
        const dSq=dx*dx+dy*dy+dz*dz+1;
        const cm=(nodeList[j].level||3)!==myLv?2.5:1.0;
        const f=repS*cm/dSq;const d=Math.sqrt(dSq);
        fx+=(dx/d)*f;fy+=(dy/d)*f;fz+=(dz/d)*f;
      }
      const rb=N/KS;fx*=rb;fy*=rb;fz*=rb;
      for(const j of adjL[i]){
        const dx=pos[j].x-pos[i].x,dy=pos[j].y-pos[i].y,dz=pos[j].z-pos[i].z;
        const d=Math.sqrt(dx*dx+dy*dy+dz*dz+1);
        const sl=(nodeList[j].level||3)===myLv?2.5:0.3;
        const f=ATT*d*sl;fx+=(dx/d)*f;fy+=(dy/d)*f;fz+=(dz/d)*f;
      }
      const mc=dynC[myLv];
      if(mc){fx+=(mc.x-pos[i].x)*CPULL*temp;fy+=(mc.y-pos[i].y)*CPULL*temp;fz+=(mc.z-pos[i].z)*CPULL*temp;}
      for(const lv in dynC){
        if(parseInt(lv)===myLv)continue;const oc=dynC[lv];
        const dx=pos[i].x-oc.x,dy=pos[i].y-oc.y,dz=pos[i].z-oc.z;
        const dSq=dx*dx+dy*dy+dz*dz+1;const f=IREP*temp/dSq;const d=Math.sqrt(dSq);
        fx+=(dx/d)*f;fy+=(dy/d)*f;fz+=(dz/d)*f;
      }
      fx-=pos[i].x*CEN;fy-=pos[i].y*CEN;fz-=pos[i].z*CEN;
      vel[i].x=(vel[i].x+fx)*DAMP;vel[i].y=(vel[i].y+fy)*DAMP;vel[i].z=(vel[i].z+fz)*DAMP;
      const maxV=30*temp+2;
      const vL=Math.sqrt(vel[i].x*vel[i].x+vel[i].y*vel[i].y+vel[i].z*vel[i].z);
      if(vL>maxV){vel[i].x=vel[i].x/vL*maxV;vel[i].y=vel[i].y/vL*maxV;vel[i].z=vel[i].z/vL*maxV;}
    }
    for(let i=0;i<N;i++){pos[i].x+=vel[i].x;pos[i].y+=vel[i].y;pos[i].z+=vel[i].z;}
  }
  let maxD=0;
  for(let i=0;i<N;i++){const d=Math.sqrt(pos[i].x*pos[i].x+pos[i].y*pos[i].y+pos[i].z*pos[i].z);if(d>maxD)maxD=d;}
  const sc=maxD>0?650/maxD:1;
  for(let i=0;i<N;i++){pos[i].x*=sc;pos[i].y*=sc;pos[i].z*=sc;}
  return pos;
}

const forcePos=computeForceLayout(nodes,edges,nodeIdxMap);
const positions=new Array(nodes.length);
for(let i=0;i<nodes.length;i++){
  const fp=forcePos[i]||{x:0,y:0,z:0};
  positions[i]=new THREE.Vector3(fp.x,fp.y,fp.z);
}
const adj={};const nodeEdgeMap={};
edges.forEach((e,ei)=>{
  const si=nodeIdxMap[e.source],ti=nodeIdxMap[e.target];
  if(si===undefined||ti===undefined)return;
  if(!adj[si])adj[si]=new Set();if(!adj[ti])adj[ti]=new Set();
  adj[si].add(ti);adj[ti].add(si);
  if(!nodeEdgeMap[si])nodeEdgeMap[si]=[];if(!nodeEdgeMap[ti])nodeEdgeMap[ti]=[];
  nodeEdgeMap[si].push(ei);nodeEdgeMap[ti].push(ei);
});

// ═══════════════════════════════════════════════════════════════
// THREE.JS SETUP
// ═══════════════════════════════════════════════════════════════

const renderer = new THREE.WebGLRenderer({antialias:false,alpha:true,powerPreference:'high-performance'});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.setPixelRatio(1);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color('#030308');
scene.fog = new THREE.FogExp2('#030308',0.00018);

const camera = new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,1,12000);
camera.position.set(900,500,900);

const controls = new OrbitControls(camera,renderer.domElement);
controls.target.set(0,0,0);
controls.enableDamping=true;controls.dampingFactor=0.06;
controls.autoRotate=true;controls.autoRotateSpeed=0.12;
controls.minDistance=80;controls.maxDistance=4000;
controls.update();

// ═══════════════════════════════════════════════════════════════
// NODES (Points + Custom Shader)
// ═══════════════════════════════════════════════════════════════

// Pre-compute dominant edge type per node for color mixing
const nodeETC={};
for(const e of edges){
  const si=nodeIdxMap[e.source],ti=nodeIdxMap[e.target];
  if(si===undefined||ti===undefined)continue;
  const t=e.type||'related_to';
  if(!nodeETC[si])nodeETC[si]={};if(!nodeETC[ti])nodeETC[ti]={};
  nodeETC[si][t]=(nodeETC[si][t]||0)+1;nodeETC[ti][t]=(nodeETC[ti][t]||0)+1;
}
const nodeDT={};
for(const idx in nodeETC){
  let mt='default',mc=0;
  for(const[t,c]of Object.entries(nodeETC[idx])){if(c>mc){mc=c;mt=t;}}
  nodeDT[idx]=mt;
}
let maxDeg=1;
for(let i=0;i<nodes.length;i++){const d=adj[i]?adj[i].size:0;if(d>maxDeg)maxDeg=d;}

const nodeGeo = new THREE.BufferGeometry();
const nCount = nodes.length;
const nPos=new Float32Array(nCount*3);
const nCol=new Float32Array(nCount*3);
const nSize=new Float32Array(nCount);
const nHighlight=new Float32Array(nCount);
const nPulse=new Float32Array(nCount);
const nActivity=new Float32Array(nCount);
const tc=new THREE.Color();
const ec=new THREE.Color();

for(let i=0;i<nCount;i++){
  const p=positions[i],n=nodes[i],s=LEVEL_STYLE[n.level]||LEVEL_STYLE[3];
  nPos[i*3]=p.x;nPos[i*3+1]=p.y;nPos[i*3+2]=p.z;
  tc.set(COLORS[n.level]);
  // Blend with dominant edge type color (35%) for variety
  const dt=nodeDT[i]||'default';
  ec.set(EDGE_COLORS[dt]||EDGE_COLORS.default);
  tc.lerp(ec,0.35);
  // Brightness by degree
  const deg=adj[i]?adj[i].size:0;
  tc.multiplyScalar(0.6+(deg/maxDeg)*0.4);
  nCol[i*3]=tc.r;nCol[i*3+1]=tc.g;nCol[i*3+2]=tc.b;
  nSize[i]=s.size;
  nHighlight[i]=1.0;
  nPulse[i]=s.pulse;
  nActivity[i]=s.activity||0.5;
}
nodeGeo.setAttribute('position',new THREE.BufferAttribute(nPos,3));
nodeGeo.setAttribute('aColor',new THREE.BufferAttribute(nCol,3));
nodeGeo.setAttribute('aSize',new THREE.BufferAttribute(nSize,1));
nodeGeo.setAttribute('aHighlight',new THREE.BufferAttribute(nHighlight,1));
nodeGeo.setAttribute('aPulse',new THREE.BufferAttribute(nPulse,1));
nodeGeo.setAttribute('aActivity',new THREE.BufferAttribute(nActivity,1));

const nodeMat = new THREE.ShaderMaterial({
  uniforms:{uTime:{value:0}},
  vertexShader:`
    attribute float aSize;
    attribute vec3 aColor;
    attribute float aHighlight;
    attribute float aPulse;
    attribute float aActivity;
    varying vec3 vColor;
    varying float vAlpha;
    varying float vActivity;
    uniform float uTime;
    void main(){
      vColor=aColor;
      vActivity=aActivity;
      float breath=1.0+sin(uTime*aPulse+position.x*.008+position.z*.006)*(.06+aActivity*.10);
      vec3 pos=position;
      pos.y+=sin(uTime*(.3+aActivity*.2)+position.x*.01+position.z*.015)*(2.0+aActivity*3.0);
      pos.x+=sin(uTime*.08+position.z*.003)*aActivity*2.0;
      pos.z+=cos(uTime*.06+position.x*.003)*aActivity*2.0;
      vAlpha=aHighlight;
      vec4 mv=modelViewMatrix*vec4(pos,1.0);
      gl_PointSize=aSize*breath*aHighlight*(500.0/-mv.z);
      gl_Position=projectionMatrix*mv;
    }
  `,
  fragmentShader:`
    varying vec3 vColor;
    varying float vAlpha;
    varying float vActivity;
    void main(){
      vec2 c=gl_PointCoord-vec2(.5);
      float d=length(c);
      if(d>.5)discard;
      float core=exp(-d*d*180.0)*0.95;
      float halo=exp(-d*d*22.0)*0.25;
      float outer=exp(-d*d*6.0)*0.06;
      float i=core+halo+outer;
      gl_FragColor=vec4(vColor*(0.85+core*0.15),i*vAlpha);
    }
  `,
  transparent:true,depthWrite:false,blending:THREE.AdditiveBlending,
});
const nodePoints = new THREE.Points(nodeGeo,nodeMat);
scene.add(nodePoints);

// ═══════════════════════════════════════════════════════════════
// EDGES (LineSegments)
// ═══════════════════════════════════════════════════════════════

const MAX_RENDERED_EDGES=12000;
const EDGE_COLORS={
  imports:'#00ff88',calls:'#ffdd00',depends_on:'#ffdd00',
  related_to:'#4488ff',similar_to:'#4488ff',
  belongs_to:'#ff6600',part_of:'#ff6600',supersedes:'#ff4444',
  evolves_from:'#aa66ff',default:'#334466',
};
const allEdgesPre=[];
edges.forEach((e,i)=>{
  const si=nodeIdxMap[e.source],ti=nodeIdxMap[e.target];
  if(si!==undefined&&ti!==undefined){
    allEdgesPre.push({si,ti,weight:e.weight,type:e.type||'related_to',idx:i});
  }
});
allEdgesPre.sort((a,b)=>b.weight-a.weight);
const validEdges=allEdgesPre.slice(0,MAX_RENDERED_EDGES);

const eCount=validEdges.length;
const ePos=new Float32Array(eCount*6);
const eCol=new Float32Array(eCount*6);
const eAlpha=new Float32Array(eCount*2);
const sc=new THREE.Color(),dc=new THREE.Color();
const alphaScale=Math.min(1.0,3000/eCount);

for(let i=0;i<eCount;i++){
  const{si,ti,weight,type}=validEdges[i];
  const s=positions[si],t=positions[ti];
  const o=i*6;
  ePos[o]=s.x;ePos[o+1]=s.y;ePos[o+2]=s.z;
  ePos[o+3]=t.x;ePos[o+4]=t.y;ePos[o+5]=t.z;
  const ec=EDGE_COLORS[type]||EDGE_COLORS.default;
  sc.set(ec);dc.set(ec);
  eCol[o]=sc.r;eCol[o+1]=sc.g;eCol[o+2]=sc.b;
  eCol[o+3]=dc.r;eCol[o+4]=dc.g;eCol[o+5]=dc.b;
  const baseAlpha=0.12+weight*0.28;
  eAlpha[i*2]=baseAlpha*alphaScale;
  eAlpha[i*2+1]=baseAlpha*alphaScale;
}

const edgeGeo=new THREE.BufferGeometry();
edgeGeo.setAttribute('position',new THREE.BufferAttribute(ePos,3));
edgeGeo.setAttribute('color',new THREE.BufferAttribute(eCol,3));
edgeGeo.setAttribute('aAlpha',new THREE.BufferAttribute(eAlpha,1));

const edgeMat=new THREE.ShaderMaterial({
  uniforms:{uTime:{value:0}},
  vertexShader:`
    attribute vec3 color;
    attribute float aAlpha;
    varying vec3 vColor;
    varying float vAlpha;
    uniform float uTime;
    void main(){
      vColor=color;
      float pulse=.5+.5*sin(uTime*1.2+length(position)*.008);
      vAlpha=aAlpha*(0.6+pulse*0.4);
      gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);
    }
  `,
  fragmentShader:`
    varying vec3 vColor;
    varying float vAlpha;
    void main(){gl_FragColor=vec4(vColor,vAlpha);}
  `,
  transparent:true,depthWrite:false,blending:THREE.AdditiveBlending,
});
const edgeLines=new THREE.LineSegments(edgeGeo,edgeMat);
scene.add(edgeLines);

// ═══════════════════════════════════════════════════════════════
// FLOWING PARTICLES (along edges)
// ═══════════════════════════════════════════════════════════════

const pData=[];// {edgeIdx, progress, speed, srcIdx, tgtIdx}
const maxParticleEdges=Math.min(eCount,2000);
for(let i=0;i<maxParticleEdges;i++){
  const{si,ti,weight}=validEdges[i];
  if(weight<0.4)continue;// only on stronger connections
  const pc=weight>0.7?2:1;
  for(let j=0;j<pc;j++){
    pData.push({
      edgeIdx:i,progress:srand(i*100+j*31),
      speed:0.15+weight*0.4+srand(i*70+j*17)*0.1,
      srcIdx:si,tgtIdx:ti
    });
  }
}
const pCount=pData.length;

const pPos=new Float32Array(pCount*3);
const pCol=new Float32Array(pCount*3);
const pSize=new Float32Array(pCount);
for(let i=0;i<pCount;i++)pSize[i]=2+srand(i*43)*2;

const particleGeo=new THREE.BufferGeometry();
particleGeo.setAttribute('position',new THREE.BufferAttribute(pPos,3));
particleGeo.setAttribute('color',new THREE.BufferAttribute(pCol,3));

const particleMat=new THREE.PointsMaterial({
  size:3,vertexColors:true,transparent:true,opacity:.7,
  blending:THREE.AdditiveBlending,depthWrite:false,sizeAttenuation:true
});
const particlePoints=new THREE.Points(particleGeo,particleMat);
scene.add(particlePoints);

// ═══════════════════════════════════════════════════════════════
// BACKGROUND STARS
// ═══════════════════════════════════════════════════════════════

const starCount=1200;
const starPos=new Float32Array(starCount*3);
const starCol=new Float32Array(starCount*3);
const stc=new THREE.Color();
for(let i=0;i<starCount;i++){
  starPos[i*3]=(srand(i*31)-.5)*6000;
  starPos[i*3+1]=(srand(i*37)-.5)*6000;
  starPos[i*3+2]=(srand(i*41)-.5)*6000;
  const hue=srand(i*53)*0.15+0.55;
  stc.setHSL(hue,0.3+srand(i*59)*0.3,0.25+srand(i*61)*0.15);
  starCol[i*3]=stc.r;starCol[i*3+1]=stc.g;starCol[i*3+2]=stc.b;
}
const starGeo=new THREE.BufferGeometry();
starGeo.setAttribute('position',new THREE.BufferAttribute(starPos,3));
starGeo.setAttribute('color',new THREE.BufferAttribute(starCol,3));
const starMat=new THREE.PointsMaterial({size:1.5,vertexColors:true,transparent:true,opacity:.6,
  blending:THREE.AdditiveBlending,depthWrite:false,sizeAttenuation:true});
scene.add(new THREE.Points(starGeo,starMat));

// ═══════════════════════════════════════════════════════════════
// INTERACTION
// ═══════════════════════════════════════════════════════════════

const raycaster=new THREE.Raycaster();
raycaster.params.Points={threshold:12};
const mouse=new THREE.Vector2();
let hoveredIdx=-1,selectedIdx=-1;
let lastActivity=Date.now();

// Camera tween state
let camTween=null; // {targetPos, targetLookAt, startPos, startLookAt, progress}

const tooltip=document.getElementById('tooltip');
const ttLabel=document.getElementById('tt-label');
const ttMeta=document.getElementById('tt-meta');
const detail=document.getElementById('detail');
const detailLabel=document.getElementById('detail-label');
const detailMeta=document.getElementById('detail-meta');
const detailConn=document.getElementById('detail-conn');
const searchInput=document.getElementById('search');
const hud=document.getElementById('hud');

renderer.domElement.addEventListener('mousemove',(e)=>{
  lastActivity=Date.now();
  mouse.x=(e.clientX/window.innerWidth)*2-1;
  mouse.y=-(e.clientY/window.innerHeight)*2+1;

  raycaster.setFromCamera(mouse,camera);
  const hits=raycaster.intersectObject(nodePoints);
  const prevHovered=hoveredIdx;

  if(hits.length>0){
    hoveredIdx=hits[0].index;
    renderer.domElement.style.cursor='pointer';
    // Tooltip
    const n=nodes[hoveredIdx];
    ttLabel.textContent=n.label;
    ttMeta.innerHTML=`Level ${n.level} &middot; ${LEVEL_NAMES[n.level]}<br>${n.type} &middot; Score: ${n.relevanceScore.toFixed(2)}`;
    tooltip.style.left=(e.clientX+14)+'px';
    tooltip.style.top=(e.clientY-10)+'px';
    tooltip.classList.add('visible');
  }else{
    hoveredIdx=-1;
    renderer.domElement.style.cursor='default';
    tooltip.classList.remove('visible');
  }

  if(prevHovered!==hoveredIdx)updateHighlights();
});

renderer.domElement.addEventListener('click',()=>{
  if(hoveredIdx>=0){
    if(selectedIdx===hoveredIdx){
      // Deselect
      selectedIdx=-1;
      detail.classList.remove('visible');
      camTween={
        startPos:camera.position.clone(),startLookAt:controls.target.clone(),
        targetPos:new THREE.Vector3(600,350,600),targetLookAt:new THREE.Vector3(0,0,0),
        progress:0
      };
      controls.autoRotate=true;
    }else{
      selectedIdx=hoveredIdx;
      showDetail(selectedIdx);
      // Fly to node
      const np=positions[selectedIdx];
      const dir=camera.position.clone().sub(np).normalize();
      camTween={
        startPos:camera.position.clone(),startLookAt:controls.target.clone(),
        targetPos:np.clone().add(dir.multiplyScalar(70)),targetLookAt:np.clone(),
        progress:0
      };
      controls.autoRotate=false;
    }
    updateHighlights();
  }else if(selectedIdx>=0){
    selectedIdx=-1;
    detail.classList.remove('visible');
    camTween={
      startPos:camera.position.clone(),startLookAt:controls.target.clone(),
      targetPos:new THREE.Vector3(600,350,600),targetLookAt:new THREE.Vector3(0,0,0),
      progress:0
    };
    controls.autoRotate=true;
    updateHighlights();
  }
});

document.getElementById('detail-close').addEventListener('click',()=>{
  selectedIdx=-1;detail.classList.remove('visible');
  controls.autoRotate=true;updateHighlights();
});

function showDetail(idx){
  const n=nodes[idx];
  detailLabel.textContent=n.label;
  const lvColor=COLORS[n.level];
  detailMeta.innerHTML=`
    <span><span style="color:${lvColor}">&bull;</span> Level ${n.level} &middot; ${LEVEL_NAMES[n.level]}</span>
    <span>${n.type}</span>
    <span>Score: ${n.relevanceScore.toFixed(2)}</span>
    <span>Accessed: ${n.accessCount}x</span>
  `;
  const connCount=adj[idx]?adj[idx].size:0;
  detailConn.textContent=`${connCount} connection${connCount!==1?'s':''}`;
  detail.classList.add('visible');
}

// ═══════════════════════════════════════════════════════════════
// HIGHLIGHTS
// ═══════════════════════════════════════════════════════════════

const searchTerm={value:''};
searchInput.addEventListener('input',(e)=>{
  searchTerm.value=e.target.value.toLowerCase();
  lastActivity=Date.now();
  updateHighlights();
});

function updateHighlights(){
  const ha=nodeGeo.attributes.aHighlight;
  const ea=edgeGeo.attributes.aAlpha;
  const hasSearch=searchTerm.value.length>0;
  const hasFocus=selectedIdx>=0;
  const connectedToHover=hoveredIdx>=0&&adj[hoveredIdx]?adj[hoveredIdx]:new Set();
  const connectedToSelected=selectedIdx>=0&&adj[selectedIdx]?adj[selectedIdx]:new Set();

  for(let i=0;i<nCount;i++){
    let h=1.0;
    if(hasSearch){
      h=nodes[i].label.toLowerCase().includes(searchTerm.value)?1.0:0.12;
    }
    if(hasFocus){
      h=connectedToSelected.has(i)||i===selectedIdx?1.0:0.1;
    }
    if(hoveredIdx>=0){
      if(i===hoveredIdx)h=Math.max(h,1.5);
      else if(connectedToHover.has(i))h=Math.max(h,1.2);
    }
    ha.array[i]=h;
  }
  ha.needsUpdate=true;

  // Edge highlights — respect level toggles
  const activeLvls={};
  const legendRows=document.querySelectorAll('.legend-row');
  const lvOrder=[5,4,3,2,1,6];
  legendRows.forEach((r,ri)=>{activeLvls[lvOrder[ri]]=r.classList.contains('active');});
  const aS=Math.min(1.0,3000/eCount);
  for(let i=0;i<eCount;i++){
    const{si,ti,weight}=validEdges[i];
    const sLv=nodes[si].level,tLv=nodes[ti].level;
    // Level toggle filter
    if(activeLvls[sLv]===false||activeLvls[tLv]===false){ea.array[i*2]=0;ea.array[i*2+1]=0;continue;}
    const baseA=0.06+weight*0.14;
    let a=baseA*aS;
    if(hasFocus){
      const connected=(si===selectedIdx||ti===selectedIdx);
      a=connected?0.4+weight*0.3:0.01;
    }
    if(hoveredIdx>=0){
      const connected=(si===hoveredIdx||ti===hoveredIdx);
      if(connected)a=Math.max(a,0.35+weight*0.3);
    }
    if(hasSearch){
      const sm=nodes[si].label.toLowerCase().includes(searchTerm.value);
      const tm=nodes[ti].label.toLowerCase().includes(searchTerm.value);
      if(!sm&&!tm)a=0.01;
    }
    ea.array[i*2]=a;ea.array[i*2+1]=a;
  }
  ea.needsUpdate=true;
}

// ═══════════════════════════════════════════════════════════════
// HUD SETUP
// ═══════════════════════════════════════════════════════════════

// Stats
document.getElementById('stats').textContent=
  `${projectName} \u00b7 ${nodes.length} nodes \u00b7 ${edges.length} connections`;

// Legend
const legendEl=document.getElementById('legend');
const levelOrder=[5,4,3,2,1,6];
levelOrder.forEach(lv=>{
  const count=(byLevel[lv]||[]).length;
  const row=document.createElement('div');
  row.className='legend-row active';
  row.innerHTML=`<span class="legend-dot" style="background:${COLORS[lv]};box-shadow:0 0 6px ${COLORS[lv]}"></span>
    <span class="legend-label">L${lv} ${LEVEL_NAMES[lv]}</span>
    <span class="legend-count">${count}</span>`;
  row.addEventListener('click',()=>{
    row.classList.toggle('active');
    const visible=row.classList.contains('active');
    // Update nodes
    (byLevel[lv]||[]).forEach(ni=>{
      const h=nodeGeo.attributes.aHighlight;
      h.array[ni]=visible?1.0:0.05;
      h.needsUpdate=true;
    });
    // Update edges — hide edges connected to disabled levels
    const ea=edgeGeo.attributes.aAlpha;
    const activeLevels={};
    legendEl.querySelectorAll('.legend-row').forEach((r,ri)=>{
      activeLevels[levelOrder[ri]]=r.classList.contains('active');
    });
    for(let i=0;i<eCount;i++){
      const{si,ti,weight}=validEdges[i];
      const sLv=nodes[si].level,tLv=nodes[ti].level;
      if(activeLevels[sLv]===false||activeLevels[tLv]===false){
        ea.array[i*2]=0;ea.array[i*2+1]=0;
      }else{
        const aS=Math.min(1.0,3000/eCount);
        const baseA=0.06+weight*0.14;
        ea.array[i*2]=baseA*aS;ea.array[i*2+1]=baseA*aS;
      }
    }
    ea.needsUpdate=true;
  });
  legendEl.appendChild(row);
});

// Keyboard
document.addEventListener('keydown',(e)=>{
  if(e.key==='Escape'&&selectedIdx>=0){
    selectedIdx=-1;detail.classList.remove('visible');
    controls.autoRotate=true;updateHighlights();
    camTween={
      startPos:camera.position.clone(),startLookAt:controls.target.clone(),
      targetPos:new THREE.Vector3(600,350,600),targetLookAt:new THREE.Vector3(0,0,0),
      progress:0
    };
  }
  if(e.key==='/'&&document.activeElement!==searchInput){
    e.preventDefault();searchInput.focus();
  }
});

// ═══════════════════════════════════════════════════════════════
// ANIMATION LOOP
// ═══════════════════════════════════════════════════════════════

const clock=new THREE.Clock();
let lastTime=0;

function animate(){
  requestAnimationFrame(animate);
  const dt=clock.getDelta();
  const t=clock.getElapsedTime();

  // Uniforms
  nodeMat.uniforms.uTime.value=t;
  edgeMat.uniforms.uTime.value=t;

  // Camera tween
  if(camTween){
    camTween.progress=Math.min(camTween.progress+dt*1.8,1);
    const ease=1-Math.pow(1-camTween.progress,3); // ease-out cubic
    camera.position.lerpVectors(camTween.startPos,camTween.targetPos,ease);
    controls.target.lerpVectors(camTween.startLookAt,camTween.targetLookAt,ease);
    if(camTween.progress>=1)camTween=null;
  }

  controls.update();

  // Update flowing particles
  const sc2=new THREE.Color(),dc2=new THREE.Color();
  for(let i=0;i<pCount;i++){
    const pd=pData[i];
    pd.progress+=pd.speed*dt;
    if(pd.progress>1)pd.progress-=1;
    const p=pd.progress;
    const sp=positions[pd.srcIdx],tp=positions[pd.tgtIdx];
    pPos[i*3]=sp.x+(tp.x-sp.x)*p;
    pPos[i*3+1]=sp.y+(tp.y-sp.y)*p;
    pPos[i*3+2]=sp.z+(tp.z-sp.z)*p;
    sc2.set(COLORS[nodes[pd.srcIdx].level]);
    dc2.set(COLORS[nodes[pd.tgtIdx].level]);
    pCol[i*3]=sc2.r+(dc2.r-sc2.r)*p;
    pCol[i*3+1]=sc2.g+(dc2.g-sc2.g)*p;
    pCol[i*3+2]=sc2.b+(dc2.b-sc2.b)*p;
  }
  particleGeo.attributes.position.needsUpdate=true;
  particleGeo.attributes.color.needsUpdate=true;

  // HUD auto-hide
  const inactive=Date.now()-lastActivity>3000;
  hud.classList.toggle('hidden',inactive&&selectedIdx<0);

  renderer.render(scene,camera);
}
animate();

// Resize
window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

</script>
</body>
</html>
