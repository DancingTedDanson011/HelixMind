<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HelixMind Brain</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{overflow:hidden;background:#030308;font-family:'JetBrains Mono',monospace;color:#ccc;user-select:none}
canvas{display:block;width:100vw;height:100vh}

/* ─── HUD ─── */
#hud{position:fixed;inset:0;pointer-events:none;z-index:10;transition:opacity .8s ease}
#hud.hidden{opacity:0}
.hud-panel{position:absolute;pointer-events:auto}

/* Top-left — Identity */
#identity{top:20px;left:24px;font-size:11px;line-height:1.6;opacity:.7}
#identity .title{font-size:14px;font-weight:500;color:#00d4ff;letter-spacing:1px;display:flex;align-items:center;gap:8px}
#identity .title .dot{width:6px;height:6px;border-radius:50%;background:#00ff88;animation:pulse-dot 2s ease infinite}
#identity .stats{color:#556;margin-top:2px}
@keyframes pulse-dot{0%,100%{opacity:.4;transform:scale(.8)}50%{opacity:1;transform:scale(1.2)}}

/* Top-right — Legend */
#legend{top:20px;right:24px;display:flex;flex-direction:column;gap:5px;font-size:10px}
.legend-row{display:flex;align-items:center;gap:8px;cursor:pointer;opacity:.6;transition:opacity .3s}
.legend-row:hover,.legend-row.active{opacity:1}
.legend-dot{width:8px;height:8px;border-radius:50%;flex-shrink:0}
.legend-label{white-space:nowrap}
.legend-count{color:#445;margin-left:auto}

/* Bottom-left — Detail Panel */
#detail{bottom:24px;left:24px;background:rgba(5,5,16,.85);border:1px solid rgba(255,255,255,.06);border-radius:12px;padding:16px 20px;max-width:320px;font-size:11px;line-height:1.7;backdrop-filter:blur(12px);opacity:0;transform:translateY(10px);transition:opacity .4s,transform .4s;pointer-events:none}
#detail.visible{opacity:1;transform:translateY(0);pointer-events:auto}
#detail .detail-label{font-size:14px;font-weight:500;color:#fff;margin-bottom:6px}
#detail .detail-meta{color:#667;display:flex;flex-wrap:wrap;gap:4px 12px}
#detail .detail-meta span{display:flex;align-items:center;gap:4px}
#detail .detail-conn{margin-top:8px;color:#556}
#detail .detail-close{position:absolute;top:8px;right:12px;cursor:pointer;color:#445;font-size:16px}
#detail .detail-close:hover{color:#fff}

/* Bottom-center — Search */
#search-wrap{bottom:24px;left:50%;transform:translateX(-50%);pointer-events:auto}
#search{background:rgba(5,5,16,.7);border:1px solid rgba(255,255,255,.08);border-radius:20px;padding:8px 20px;width:260px;font-family:inherit;font-size:11px;color:#ccc;outline:none;backdrop-filter:blur(10px);transition:border-color .3s,width .3s}
#search:focus{border-color:rgba(0,212,255,.3);width:320px}
#search::placeholder{color:#334}

/* Tooltip */
#tooltip{position:fixed;background:rgba(5,5,16,.9);border:1px solid rgba(255,255,255,.08);border-radius:8px;padding:8px 14px;font-size:10px;line-height:1.6;pointer-events:none;opacity:0;transition:opacity .2s;backdrop-filter:blur(8px);z-index:20;max-width:220px}
#tooltip.visible{opacity:1}
#tooltip .tt-label{color:#fff;font-weight:500;font-size:11px}
#tooltip .tt-meta{color:#556}
</style>
</head>
<body>

<!-- HUD -->
<div id="hud">
  <div id="identity" class="hud-panel">
    <div class="title"><span class="dot"></span> HelixMind Brain</div>
    <div class="stats" id="stats"></div>
  </div>

  <div id="legend" class="hud-panel"></div>

  <div id="detail" class="hud-panel">
    <div class="detail-close" id="detail-close">&times;</div>
    <div class="detail-label" id="detail-label"></div>
    <div class="detail-meta" id="detail-meta"></div>
    <div class="detail-conn" id="detail-conn"></div>
  </div>

  <div id="search-wrap" class="hud-panel">
    <input id="search" type="text" placeholder="Search nodes..." spellcheck="false">
  </div>
</div>

<div id="tooltip">
  <div class="tt-label" id="tt-label"></div>
  <div class="tt-meta" id="tt-meta"></div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// ═══════════════════════════════════════════════════════════════
// CONSTANTS
// ═══════════════════════════════════════════════════════════════

const COLORS = {
  1: '#00ffff', 2: '#00ff88', 3: '#ffaa33',
  4: '#2255dd', 5: '#9b59b6', 6: '#f1c40f',
};
const LEVEL_NAMES = {
  1: 'Instant', 2: 'Focus', 3: 'Context',
  4: 'Knowledge', 5: 'Wisdom', 6: 'Web',
};
const SPATIAL = {
  5: { iR: 10,  oR: 70,  yBase: 0,    yS: 60,  size: 52, pulse: 0.3 },
  4: { iR: 80,  oR: 180, yBase: 120,  yS: 80,  size: 42, pulse: 0.5 },
  3: { iR: 160, oR: 320, yBase: -80,  yS: 100, size: 36, pulse: 0.8 },
  2: { iR: 280, oR: 440, yBase: 200,  yS: 120, size: 28, pulse: 1.2 },
  1: { iR: 400, oR: 560, yBase: -180, yS: 140, size: 22, pulse: 2.0 },
  6: { iR: 500, oR: 680, yBase: 300,  yS: 160, size: 34, pulse: 0.6 },
};

function srand(s){const x=Math.sin(s*9301+49297)*49297;return x-Math.floor(x)}

// ═══════════════════════════════════════════════════════════════
// DEMO DATA
// ═══════════════════════════════════════════════════════════════

const T = [
  // L5 Wisdom
  {l:'SOLID Principles',t:'pattern',lv:5},{l:'Separation of Concerns',t:'pattern',lv:5},
  {l:'Test-Driven Development',t:'pattern',lv:5},{l:'Event-Driven Architecture',t:'architecture',lv:5},
  {l:'Functional Composition',t:'pattern',lv:5},{l:'Clean Architecture',t:'architecture',lv:5},
  {l:'Immutable Data',t:'pattern',lv:5},
  // L4 Knowledge
  {l:'React Component Lifecycle',t:'code',lv:4},{l:'TypeScript Generics',t:'code',lv:4},
  {l:'SQL Query Optimization',t:'decision',lv:4},{l:'REST API Design',t:'pattern',lv:4},
  {l:'Git Branching Strategy',t:'decision',lv:4},{l:'Docker Containerization',t:'architecture',lv:4},
  {l:'WebSocket Protocol',t:'code',lv:4},{l:'CSS Grid Layout',t:'code',lv:4},
  {l:'Promise Patterns',t:'pattern',lv:4},{l:'State Machine Design',t:'architecture',lv:4},
  {l:'Middleware Pipeline',t:'pattern',lv:4},{l:'Error Boundaries',t:'pattern',lv:4},
  {l:'Database Indexing',t:'decision',lv:4},{l:'OAuth2 Flow',t:'pattern',lv:4},
  // L3 Context
  {l:'Auth Middleware Refactor',t:'code',lv:3},{l:'Payment Integration',t:'code',lv:3},
  {l:'Dashboard Redesign',t:'summary',lv:3},{l:'API Rate Limiting',t:'code',lv:3},
  {l:'DB Migration v3',t:'code',lv:3},{l:'Search Optimization',t:'code',lv:3},
  {l:'Caching Strategy',t:'decision',lv:3},{l:'WS Reconnection',t:'code',lv:3},
  {l:'Form Validation',t:'code',lv:3},{l:'Image Pipeline',t:'code',lv:3},
  {l:'Email Notifications',t:'code',lv:3},{l:'Role-Based Access',t:'code',lv:3},
  {l:'CI/CD Update',t:'summary',lv:3},{l:'Monitoring Setup',t:'code',lv:3},
  {l:'Performance Profiling',t:'summary',lv:3},{l:'Session Management',t:'code',lv:3},
  {l:'Logging Framework',t:'architecture',lv:3},{l:'Error Handling v2',t:'code',lv:3},
  // L2 Focus
  {l:'Fix Login Redirect',t:'error',lv:2},{l:'Update Dependencies',t:'code',lv:2},
  {l:'Dark Mode Toggle',t:'code',lv:2},{l:'Bundle Size Opt',t:'code',lv:2},
  {l:'Implement Pagination',t:'code',lv:2},{l:'Search Autocomplete',t:'code',lv:2},
  {l:'Fix Memory Leak',t:'error',lv:2},{l:'API Docs Update',t:'summary',lv:2},
  {l:'Export Feature',t:'code',lv:2},{l:'Refactor Settings',t:'code',lv:2},
  {l:'Add Tests for Auth',t:'code',lv:2},{l:'Optimize Queries',t:'code',lv:2},
  // L1 Instant
  {l:'Review PR #247',t:'code',lv:1},{l:'Debug Test Failure',t:'error',lv:1},
  {l:'Deployment Issue',t:'error',lv:1},{l:'Cleanup Imports',t:'code',lv:1},
  {l:'Quick CSS Fix',t:'code',lv:1},{l:'Check CI Status',t:'code',lv:1},
  {l:'Read Error Logs',t:'error',lv:1},{l:'Standup Notes',t:'summary',lv:1},
  {l:'Hotfix: Null Check',t:'error',lv:1},{l:'Merge Conflicts',t:'code',lv:1},
  // L6 Web
  {l:'React 19 Release',t:'pattern',lv:6},{l:'Next.js 15 Migration',t:'pattern',lv:6},
  {l:'Prisma v6 Changelog',t:'pattern',lv:6},{l:'TS 5.7 Features',t:'pattern',lv:6},
  {l:'Tailwind v4 Guide',t:'pattern',lv:6},{l:'Node.js 22 LTS',t:'pattern',lv:6},
  {l:'Bun Benchmarks',t:'pattern',lv:6},{l:'Deno 2.0',t:'pattern',lv:6},
];

const nodes = T.map((n,i)=>({id:'n'+i,label:n.l,type:n.t,level:n.lv,
  relevanceScore:Math.max(.1,1-(n.lv-1)*.15+srand(i*.37)*.2),
  accessCount:Math.floor(srand(i*.53)*50+1)}));

// Generate edges
const E=[];
function addE(s,t,tp,w){if(s<nodes.length&&t<nodes.length)E.push({source:'n'+s,target:'n'+t,type:tp,weight:w})}
// L5 internal
addE(0,1,'similar_to',.8);addE(0,2,'similar_to',.7);addE(3,5,'similar_to',.9);addE(4,6,'similar_to',.6);addE(1,5,'similar_to',.7);
// L5→L4
addE(0,7,'evolves_from',.9);addE(0,10,'evolves_from',.7);addE(2,7,'evolves_from',.8);
addE(3,14,'evolves_from',.8);addE(3,16,'evolves_from',.7);addE(5,12,'evolves_from',.8);
addE(4,15,'evolves_from',.6);addE(1,17,'evolves_from',.7);addE(6,8,'evolves_from',.5);
// L4 internal
addE(7,17,'similar_to',.6);addE(8,15,'similar_to',.5);addE(10,9,'calls',.7);
addE(13,16,'depends_on',.8);addE(11,12,'related_to',.5);addE(14,19,'depends_on',.7);addE(18,9,'calls',.8);
// L4→L3
addE(7,21,'evolves_from',.8);addE(10,23,'evolves_from',.7);addE(9,24,'calls',.6);
addE(13,27,'evolves_from',.7);addE(17,30,'evolves_from',.6);addE(19,31,'evolves_from',.8);
addE(15,28,'calls',.5);addE(16,35,'evolves_from',.7);addE(18,25,'calls',.6);addE(14,36,'calls',.5);
addE(12,22,'related_to',.4);addE(8,37,'calls',.5);
// L3 internal
addE(21,31,'depends_on',.8);addE(22,28,'calls',.6);addE(23,26,'depends_on',.7);
addE(25,27,'depends_on',.5);addE(29,30,'calls',.6);addE(33,34,'similar_to',.5);
addE(24,25,'depends_on',.7);addE(32,33,'related_to',.4);addE(26,36,'calls',.5);addE(35,37,'depends_on',.6);
// L3→L2
addE(21,38,'evolves_from',.7);addE(28,42,'evolves_from',.6);addE(25,43,'evolves_from',.5);
addE(22,40,'calls',.6);addE(23,41,'depends_on',.5);addE(29,44,'evolves_from',.7);
addE(37,46,'evolves_from',.6);addE(26,47,'calls',.5);addE(31,48,'depends_on',.6);addE(24,49,'calls',.4);
// L2 internal
addE(38,46,'related_to',.5);addE(40,41,'similar_to',.4);addE(42,43,'depends_on',.6);
addE(44,45,'calls',.5);addE(47,49,'related_to',.3);
// L2→L1
addE(38,50,'evolves_from',.6);addE(46,51,'calls',.5);addE(40,54,'calls',.4);
addE(42,56,'evolves_from',.5);addE(49,57,'calls',.4);addE(44,52,'depends_on',.5);addE(41,59,'calls',.4);
// L1 internal
addE(50,51,'related_to',.4);addE(52,53,'depends_on',.5);addE(54,55,'similar_to',.3);addE(56,57,'calls',.4);
// L6→various
addE(60,7,'imports',.7);addE(61,21,'imports',.6);addE(62,24,'imports',.5);addE(63,8,'imports',.6);
addE(64,14,'imports',.5);addE(65,13,'imports',.4);addE(66,41,'imports',.5);addE(67,12,'imports',.4);
addE(60,61,'similar_to',.4);addE(63,64,'similar_to',.3);addE(65,66,'similar_to',.3);

const edges = E;
const projectName = 'HelixMind';

// ═══════════════════════════════════════════════════════════════
// POSITIONS
// ═══════════════════════════════════════════════════════════════

const byLevel = {};
nodes.forEach((n,i)=>{if(!byLevel[n.level])byLevel[n.level]=[];byLevel[n.level].push(i)});

const positions = new Array(nodes.length);
for(const[lv,indices]of Object.entries(byLevel)){
  const s = SPATIAL[lv]||SPATIAL[3];
  const c = indices.length;
  indices.forEach((ni,j)=>{
    const angle=(j/Math.max(c,1))*Math.PI*2;
    const r=s.iR+srand(ni*7)*(s.oR-s.iR);
    const spiral=angle+r*0.004;
    const y=(s.yBase||0)+(srand(ni*11)-.5)*s.yS;
    positions[ni]=new THREE.Vector3(Math.cos(spiral)*r,y,Math.sin(spiral)*r);
  });
}

// Adjacency
const nodeIdxMap={};nodes.forEach((n,i)=>{nodeIdxMap[n.id]=i});
const adj={};const nodeEdgeMap={};
edges.forEach((e,ei)=>{
  const si=nodeIdxMap[e.source],ti=nodeIdxMap[e.target];
  if(si===undefined||ti===undefined)return;
  if(!adj[si])adj[si]=new Set();if(!adj[ti])adj[ti]=new Set();
  adj[si].add(ti);adj[ti].add(si);
  if(!nodeEdgeMap[si])nodeEdgeMap[si]=[];if(!nodeEdgeMap[ti])nodeEdgeMap[ti]=[];
  nodeEdgeMap[si].push(ei);nodeEdgeMap[ti].push(ei);
});

// ═══════════════════════════════════════════════════════════════
// THREE.JS SETUP
// ═══════════════════════════════════════════════════════════════

const renderer = new THREE.WebGLRenderer({antialias:false,alpha:true,powerPreference:'high-performance'});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.setPixelRatio(1);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color('#030308');
scene.fog = new THREE.FogExp2('#030308',0.0004);

const camera = new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,1,8000);
camera.position.set(500,350,700);

const controls = new OrbitControls(camera,renderer.domElement);
controls.target.set(0,60,0);
controls.enableDamping=true;controls.dampingFactor=0.06;
controls.autoRotate=true;controls.autoRotateSpeed=0.08;
controls.minDistance=80;controls.maxDistance=2500;
controls.maxPolarAngle=Math.PI*.85;controls.minPolarAngle=Math.PI*.15;
controls.update();

// ═══════════════════════════════════════════════════════════════
// NODES (Points + Custom Shader)
// ═══════════════════════════════════════════════════════════════

const nodeGeo = new THREE.BufferGeometry();
const nCount = nodes.length;
const nPos=new Float32Array(nCount*3);
const nCol=new Float32Array(nCount*3);
const nSize=new Float32Array(nCount);
const nHighlight=new Float32Array(nCount);
const nPulse=new Float32Array(nCount);
const tc=new THREE.Color();

for(let i=0;i<nCount;i++){
  const p=positions[i],n=nodes[i],s=SPATIAL[n.level]||SPATIAL[3];
  nPos[i*3]=p.x;nPos[i*3+1]=p.y;nPos[i*3+2]=p.z;
  tc.set(COLORS[n.level]);
  nCol[i*3]=tc.r;nCol[i*3+1]=tc.g;nCol[i*3+2]=tc.b;
  nSize[i]=s.size;
  nHighlight[i]=1.0;
  nPulse[i]=s.pulse;
}
nodeGeo.setAttribute('position',new THREE.BufferAttribute(nPos,3));
nodeGeo.setAttribute('aColor',new THREE.BufferAttribute(nCol,3));
nodeGeo.setAttribute('aSize',new THREE.BufferAttribute(nSize,1));
nodeGeo.setAttribute('aHighlight',new THREE.BufferAttribute(nHighlight,1));
nodeGeo.setAttribute('aPulse',new THREE.BufferAttribute(nPulse,1));

const nodeMat = new THREE.ShaderMaterial({
  uniforms:{uTime:{value:0}},
  vertexShader:`
    attribute float aSize;
    attribute vec3 aColor;
    attribute float aHighlight;
    attribute float aPulse;
    varying vec3 vColor;
    varying float vAlpha;
    uniform float uTime;
    void main(){
      vColor=aColor;
      float breath=1.0+sin(uTime*aPulse+position.x*.008+position.z*.006)*.12;
      vec3 pos=position;
      pos.y+=sin(uTime*.3+position.x*.01+position.z*.015)*3.0;
      vAlpha=aHighlight;
      vec4 mv=modelViewMatrix*vec4(pos,1.0);
      gl_PointSize=aSize*breath*aHighlight*(500.0/-mv.z);
      gl_Position=projectionMatrix*mv;
    }
  `,
  fragmentShader:`
    varying vec3 vColor;
    varying float vAlpha;
    void main(){
      vec2 c=gl_PointCoord-vec2(.5);
      float d=length(c);
      if(d>.5)discard;
      float core=exp(-d*d*100.0);
      float g1=exp(-d*d*18.0)*.45;
      float g2=exp(-d*d*4.0)*.15;
      float g3=exp(-d*d*1.2)*.06;
      float i=core+g1+g2+g3;
      gl_FragColor=vec4(vColor*(1.0+core*.5),i*vAlpha);
    }
  `,
  transparent:true,depthWrite:false,blending:THREE.AdditiveBlending,
});
const nodePoints = new THREE.Points(nodeGeo,nodeMat);
scene.add(nodePoints);

// ═══════════════════════════════════════════════════════════════
// EDGES (LineSegments)
// ═══════════════════════════════════════════════════════════════

const validEdges=[];
edges.forEach((e,i)=>{
  const si=nodeIdxMap[e.source],ti=nodeIdxMap[e.target];
  if(si!==undefined&&ti!==undefined)validEdges.push({si,ti,weight:e.weight,idx:i});
});

const eCount=validEdges.length;
const ePos=new Float32Array(eCount*6);
const eCol=new Float32Array(eCount*6);
const eAlpha=new Float32Array(eCount*2);
const sc=new THREE.Color(),dc=new THREE.Color();

for(let i=0;i<eCount;i++){
  const{si,ti,weight}=validEdges[i];
  const s=positions[si],t=positions[ti];
  const o=i*6;
  ePos[o]=s.x;ePos[o+1]=s.y;ePos[o+2]=s.z;
  ePos[o+3]=t.x;ePos[o+4]=t.y;ePos[o+5]=t.z;
  sc.set(COLORS[nodes[si].level]);dc.set(COLORS[nodes[ti].level]);
  eCol[o]=sc.r;eCol[o+1]=sc.g;eCol[o+2]=sc.b;
  eCol[o+3]=dc.r;eCol[o+4]=dc.g;eCol[o+5]=dc.b;
  eAlpha[i*2]=0.15+weight*0.1;
  eAlpha[i*2+1]=0.15+weight*0.1;
}

const edgeGeo=new THREE.BufferGeometry();
edgeGeo.setAttribute('position',new THREE.BufferAttribute(ePos,3));
edgeGeo.setAttribute('color',new THREE.BufferAttribute(eCol,3));
edgeGeo.setAttribute('aAlpha',new THREE.BufferAttribute(eAlpha,1));

const edgeMat=new THREE.ShaderMaterial({
  uniforms:{uTime:{value:0}},
  vertexShader:`
    attribute vec3 color;
    attribute float aAlpha;
    varying vec3 vColor;
    varying float vAlpha;
    uniform float uTime;
    void main(){
      vColor=color;
      float pulse=.5+.5*sin(uTime*1.2+length(position)*.008);
      vAlpha=aAlpha*(0.6+pulse*0.4);
      gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);
    }
  `,
  fragmentShader:`
    varying vec3 vColor;
    varying float vAlpha;
    void main(){gl_FragColor=vec4(vColor,vAlpha);}
  `,
  transparent:true,depthWrite:false,blending:THREE.AdditiveBlending,
});
const edgeLines=new THREE.LineSegments(edgeGeo,edgeMat);
scene.add(edgeLines);

// ═══════════════════════════════════════════════════════════════
// FLOWING PARTICLES (along edges)
// ═══════════════════════════════════════════════════════════════

const PARTICLES_PER_EDGE=3;
const pCount=eCount*PARTICLES_PER_EDGE;
const pData=[];// {edgeIdx, progress, speed, srcIdx, tgtIdx}
for(let i=0;i<eCount;i++){
  const{si,ti,weight}=validEdges[i];
  for(let j=0;j<PARTICLES_PER_EDGE;j++){
    pData.push({
      edgeIdx:i,progress:srand(i*100+j*31),
      speed:0.2+weight*0.5+srand(i*70+j*17)*0.15,
      srcIdx:si,tgtIdx:ti
    });
  }
}

const pPos=new Float32Array(pCount*3);
const pCol=new Float32Array(pCount*3);
const pSize=new Float32Array(pCount);
for(let i=0;i<pCount;i++)pSize[i]=2+srand(i*43)*2;

const particleGeo=new THREE.BufferGeometry();
particleGeo.setAttribute('position',new THREE.BufferAttribute(pPos,3));
particleGeo.setAttribute('color',new THREE.BufferAttribute(pCol,3));

const particleMat=new THREE.PointsMaterial({
  size:3,vertexColors:true,transparent:true,opacity:.7,
  blending:THREE.AdditiveBlending,depthWrite:false,sizeAttenuation:true
});
const particlePoints=new THREE.Points(particleGeo,particleMat);
scene.add(particlePoints);

// ═══════════════════════════════════════════════════════════════
// BACKGROUND STARS
// ═══════════════════════════════════════════════════════════════

const starCount=700;
const starPos=new Float32Array(starCount*3);
for(let i=0;i<starCount;i++){
  starPos[i*3]=(srand(i*31)-.5)*5000;
  starPos[i*3+1]=(srand(i*37)-.5)*5000;
  starPos[i*3+2]=(srand(i*41)-.5)*5000;
}
const starGeo=new THREE.BufferGeometry();
starGeo.setAttribute('position',new THREE.BufferAttribute(starPos,3));
const starMat=new THREE.PointsMaterial({size:1.2,color:'#223344',transparent:true,opacity:.5,
  blending:THREE.AdditiveBlending,depthWrite:false,sizeAttenuation:true});
scene.add(new THREE.Points(starGeo,starMat));

// ═══════════════════════════════════════════════════════════════
// INTERACTION
// ═══════════════════════════════════════════════════════════════

const raycaster=new THREE.Raycaster();
raycaster.params.Points={threshold:12};
const mouse=new THREE.Vector2();
let hoveredIdx=-1,selectedIdx=-1;
let lastActivity=Date.now();

// Camera tween state
let camTween=null; // {targetPos, targetLookAt, startPos, startLookAt, progress}

const tooltip=document.getElementById('tooltip');
const ttLabel=document.getElementById('tt-label');
const ttMeta=document.getElementById('tt-meta');
const detail=document.getElementById('detail');
const detailLabel=document.getElementById('detail-label');
const detailMeta=document.getElementById('detail-meta');
const detailConn=document.getElementById('detail-conn');
const searchInput=document.getElementById('search');
const hud=document.getElementById('hud');

renderer.domElement.addEventListener('mousemove',(e)=>{
  lastActivity=Date.now();
  mouse.x=(e.clientX/window.innerWidth)*2-1;
  mouse.y=-(e.clientY/window.innerHeight)*2+1;

  raycaster.setFromCamera(mouse,camera);
  const hits=raycaster.intersectObject(nodePoints);
  const prevHovered=hoveredIdx;

  if(hits.length>0){
    hoveredIdx=hits[0].index;
    renderer.domElement.style.cursor='pointer';
    // Tooltip
    const n=nodes[hoveredIdx];
    ttLabel.textContent=n.label;
    ttMeta.innerHTML=`Level ${n.level} &middot; ${LEVEL_NAMES[n.level]}<br>${n.type} &middot; Score: ${n.relevanceScore.toFixed(2)}`;
    tooltip.style.left=(e.clientX+14)+'px';
    tooltip.style.top=(e.clientY-10)+'px';
    tooltip.classList.add('visible');
  }else{
    hoveredIdx=-1;
    renderer.domElement.style.cursor='default';
    tooltip.classList.remove('visible');
  }

  if(prevHovered!==hoveredIdx)updateHighlights();
});

renderer.domElement.addEventListener('click',()=>{
  if(hoveredIdx>=0){
    if(selectedIdx===hoveredIdx){
      // Deselect
      selectedIdx=-1;
      detail.classList.remove('visible');
      camTween={
        startPos:camera.position.clone(),startLookAt:controls.target.clone(),
        targetPos:new THREE.Vector3(500,350,700),targetLookAt:new THREE.Vector3(0,60,0),
        progress:0
      };
      controls.autoRotate=true;
    }else{
      selectedIdx=hoveredIdx;
      showDetail(selectedIdx);
      // Fly to node
      const np=positions[selectedIdx];
      const dir=camera.position.clone().sub(np).normalize();
      camTween={
        startPos:camera.position.clone(),startLookAt:controls.target.clone(),
        targetPos:np.clone().add(dir.multiplyScalar(70)),targetLookAt:np.clone(),
        progress:0
      };
      controls.autoRotate=false;
    }
    updateHighlights();
  }else if(selectedIdx>=0){
    selectedIdx=-1;
    detail.classList.remove('visible');
    camTween={
      startPos:camera.position.clone(),startLookAt:controls.target.clone(),
      targetPos:new THREE.Vector3(500,350,700),targetLookAt:new THREE.Vector3(0,60,0),
      progress:0
    };
    controls.autoRotate=true;
    updateHighlights();
  }
});

document.getElementById('detail-close').addEventListener('click',()=>{
  selectedIdx=-1;detail.classList.remove('visible');
  controls.autoRotate=true;updateHighlights();
});

function showDetail(idx){
  const n=nodes[idx];
  detailLabel.textContent=n.label;
  const lvColor=COLORS[n.level];
  detailMeta.innerHTML=`
    <span><span style="color:${lvColor}">&bull;</span> Level ${n.level} &middot; ${LEVEL_NAMES[n.level]}</span>
    <span>${n.type}</span>
    <span>Score: ${n.relevanceScore.toFixed(2)}</span>
    <span>Accessed: ${n.accessCount}x</span>
  `;
  const connCount=adj[idx]?adj[idx].size:0;
  detailConn.textContent=`${connCount} connection${connCount!==1?'s':''}`;
  detail.classList.add('visible');
}

// ═══════════════════════════════════════════════════════════════
// HIGHLIGHTS
// ═══════════════════════════════════════════════════════════════

const searchTerm={value:''};
searchInput.addEventListener('input',(e)=>{
  searchTerm.value=e.target.value.toLowerCase();
  lastActivity=Date.now();
  updateHighlights();
});

function updateHighlights(){
  const ha=nodeGeo.attributes.aHighlight;
  const ea=edgeGeo.attributes.aAlpha;
  const hasSearch=searchTerm.value.length>0;
  const hasFocus=selectedIdx>=0;
  const connectedToHover=hoveredIdx>=0&&adj[hoveredIdx]?adj[hoveredIdx]:new Set();
  const connectedToSelected=selectedIdx>=0&&adj[selectedIdx]?adj[selectedIdx]:new Set();

  for(let i=0;i<nCount;i++){
    let h=1.0;
    if(hasSearch){
      h=nodes[i].label.toLowerCase().includes(searchTerm.value)?1.0:0.12;
    }
    if(hasFocus){
      h=connectedToSelected.has(i)||i===selectedIdx?1.0:0.1;
    }
    if(hoveredIdx>=0){
      if(i===hoveredIdx)h=Math.max(h,1.5);
      else if(connectedToHover.has(i))h=Math.max(h,1.2);
    }
    ha.array[i]=h;
  }
  ha.needsUpdate=true;

  // Edge highlights
  for(let i=0;i<eCount;i++){
    const{si,ti,weight}=validEdges[i];
    let a=0.15+weight*0.1;
    if(hasFocus){
      const connected=(si===selectedIdx||ti===selectedIdx);
      a=connected?0.4+weight*0.3:0.02;
    }
    if(hoveredIdx>=0){
      const connected=(si===hoveredIdx||ti===hoveredIdx);
      if(connected)a=Math.max(a,0.35+weight*0.3);
    }
    if(hasSearch){
      const sm=nodes[si].label.toLowerCase().includes(searchTerm.value);
      const tm=nodes[ti].label.toLowerCase().includes(searchTerm.value);
      if(!sm&&!tm)a=0.02;
    }
    ea.array[i*2]=a;ea.array[i*2+1]=a;
  }
  ea.needsUpdate=true;
}

// ═══════════════════════════════════════════════════════════════
// HUD SETUP
// ═══════════════════════════════════════════════════════════════

// Stats
document.getElementById('stats').textContent=
  `${projectName} \u00b7 ${nodes.length} nodes \u00b7 ${edges.length} connections`;

// Legend
const legendEl=document.getElementById('legend');
const levelOrder=[5,4,3,2,1,6];
levelOrder.forEach(lv=>{
  const count=(byLevel[lv]||[]).length;
  const row=document.createElement('div');
  row.className='legend-row active';
  row.innerHTML=`<span class="legend-dot" style="background:${COLORS[lv]};box-shadow:0 0 6px ${COLORS[lv]}"></span>
    <span class="legend-label">L${lv} ${LEVEL_NAMES[lv]}</span>
    <span class="legend-count">${count}</span>`;
  row.addEventListener('click',()=>{
    row.classList.toggle('active');
    const visible=row.classList.contains('active');
    (byLevel[lv]||[]).forEach(ni=>{
      const h=nodeGeo.attributes.aHighlight;
      h.array[ni]=visible?1.0:0.05;
      h.needsUpdate=true;
    });
  });
  legendEl.appendChild(row);
});

// Keyboard
document.addEventListener('keydown',(e)=>{
  if(e.key==='Escape'&&selectedIdx>=0){
    selectedIdx=-1;detail.classList.remove('visible');
    controls.autoRotate=true;updateHighlights();
    camTween={
      startPos:camera.position.clone(),startLookAt:controls.target.clone(),
      targetPos:new THREE.Vector3(500,350,700),targetLookAt:new THREE.Vector3(0,60,0),
      progress:0
    };
  }
  if(e.key==='/'&&document.activeElement!==searchInput){
    e.preventDefault();searchInput.focus();
  }
});

// ═══════════════════════════════════════════════════════════════
// ANIMATION LOOP
// ═══════════════════════════════════════════════════════════════

const clock=new THREE.Clock();
let lastTime=0;

function animate(){
  requestAnimationFrame(animate);
  const dt=clock.getDelta();
  const t=clock.getElapsedTime();

  // Uniforms
  nodeMat.uniforms.uTime.value=t;
  edgeMat.uniforms.uTime.value=t;

  // Camera tween
  if(camTween){
    camTween.progress=Math.min(camTween.progress+dt*1.8,1);
    const ease=1-Math.pow(1-camTween.progress,3); // ease-out cubic
    camera.position.lerpVectors(camTween.startPos,camTween.targetPos,ease);
    controls.target.lerpVectors(camTween.startLookAt,camTween.targetLookAt,ease);
    if(camTween.progress>=1)camTween=null;
  }

  controls.update();

  // Update flowing particles
  const sc2=new THREE.Color(),dc2=new THREE.Color();
  for(let i=0;i<pCount;i++){
    const pd=pData[i];
    pd.progress+=pd.speed*dt;
    if(pd.progress>1)pd.progress-=1;
    const p=pd.progress;
    const sp=positions[pd.srcIdx],tp=positions[pd.tgtIdx];
    pPos[i*3]=sp.x+(tp.x-sp.x)*p;
    pPos[i*3+1]=sp.y+(tp.y-sp.y)*p;
    pPos[i*3+2]=sp.z+(tp.z-sp.z)*p;
    sc2.set(COLORS[nodes[pd.srcIdx].level]);
    dc2.set(COLORS[nodes[pd.tgtIdx].level]);
    pCol[i*3]=sc2.r+(dc2.r-sc2.r)*p;
    pCol[i*3+1]=sc2.g+(dc2.g-sc2.g)*p;
    pCol[i*3+2]=sc2.b+(dc2.b-sc2.b)*p;
  }
  particleGeo.attributes.position.needsUpdate=true;
  particleGeo.attributes.color.needsUpdate=true;

  // HUD auto-hide
  const inactive=Date.now()-lastActivity>3000;
  hud.classList.toggle('hidden',inactive&&selectedIdx<0);

  renderer.render(scene,camera);
}
animate();

// Resize
window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

</script>
</body>
</html>
